const { where2obj } = require('../../_runtime/common/utils/cqn')

const _isNavToDraftAdmin = path => path.length > 1 && path[path.length - 1] === 'DraftAdministrativeData'

const _lastValidRef = ref => {
  for (let i = ref.length - 1; i >= 0; i--) {
    if (ref[i] in { DraftAdministrativeData: 1, SiblingEntity: 1 }) continue
    return ref[i]
  }
}

const _odataContext = (query, options) => {
  const { result, isCollection, edmName } = options

  let path = '$metadata'
  if (query._target.kind === 'service') {
    return path
  }

  const {
    _target: { _isSingleton: isSingleton },
    _propertyAccess: propertyAccess
  } = query

  path += '#'

  // REVISIT: subselect is treated as empty array
  const ref =
    query.SELECT?.from?.ref ?? query.UPDATE?.entity?.ref ?? query.INSERT?.into?.ref ?? query.DELETE?.from?.ref ?? []

  const isNavToDraftAdmin = _isNavToDraftAdmin(ref)

  if (ref.length > 1) {
    // prepend for relative path
    path = '../'.repeat(ref.length - 1) + path
  }
  const lastRef = ref.at(-1)
  let entityName = isNavToDraftAdmin ? ref[0].id ?? ref[0] : query._target.name ?? edmName
  const serviceName = query._target._service?.name

  if (query._target._isContained) {
    let cur = query._target
    let refIndex = ref.length - 1

    entityName = lastRef.id ?? lastRef

    while (cur._isContained) {
      cur = cur.elements.up_._target
      refIndex--
      const curName = ref[refIndex].id ?? ref[refIndex]
      const where = ref[refIndex].where

      if (where) {
        let keys
        if (where.length > 3) {
          // multiple keys should contain key name
          const _keys = where2obj(where)
          keys = Object.keys(_keys).map(k => {
            return k + '=' + _keys[k]
          })
        } else {
          // single keys can just contain value
          keys = [where.at(-1).val]
        }
        entityName = curName + '(' + keys.join(',') + ')' + '/' + entityName
      } else {
        // REVISIT: is this correct?
        entityName = curName + '/' + entityName
      }
    }
  }

  if (serviceName) {
    entityName = entityName.replace(serviceName + '.', '').replace(/\./g, '_')
  }

  path += entityName

  if (propertyAccess) {
    path = '../' + path

    const lastValidRef = _lastValidRef(ref)
    if (lastValidRef.where) {
      let keys
      const isSibling = lastRef === 'SiblingEntity'
      if (lastValidRef.where.length > 3) {
        // multiple keys should contain key name
        const _keys = where2obj(lastValidRef.where)
        keys = Object.keys(_keys).map(k => {
          if (k === 'IsActiveEntity' && isSibling) return k + '=' + !_keys[k]
          return k + '=' + _keys[k]
        })
      } else {
        // single keys can just contain value
        keys = [lastValidRef.where.at(-1).val]
      }

      path += '(' + keys.join(',') + ')'
    } else if (!isSingleton) {
      // use keys from result if not in query
      const _keys = Object.keys(query._target.keys)
      let keyString
      if (_keys.length === 1) {
        keyString = result[_keys[0]]
      } else {
        keyString = _keys.map(k => k.name + '=' + result[k.name]).join(',')
      }
      path += '(' + keyString + ')'
    }

    if (isNavToDraftAdmin) {
      path += '/' + lastRef
    }

    path += '/' + propertyAccess
  } else if (isNavToDraftAdmin) {
    const lastValidRef = _lastValidRef(ref)
    if (lastValidRef.where) {
      let keys
      const isSibling = lastRef === 'SiblingEntity'
      if (lastValidRef.where.length > 3) {
        // multiple keys should contain key name
        const _keys = where2obj(lastValidRef.where)
        keys = Object.keys(_keys).map(k => {
          if (k === 'IsActiveEntity' && isSibling) return k + '=' + !_keys[k]
          return k + '=' + _keys[k]
        })
      } else {
        // single keys can just contain value
        keys = [lastValidRef.where.at(-1).val]
      }

      path += '(' + keys.join(',') + ')'
    }
    path += '/' + lastRef
  }

  if ((!isCollection && !isSingleton && !propertyAccess) || (isNavToDraftAdmin && !propertyAccess)) {
    path += '/$entity'
  }

  return path
}

/**
 * TODO
 *
 * @param {*} query
 * @param {*} [options]
 * @param {*} [options.result]
 * @param {*} [options.isCollection]
 * @param {*} [options.edmName]
 * @returns
 */
module.exports = function getODataMetadata(query, options = {}) {
  if (!query._target) return

  const context = _odataContext(query, options)

  return { context }
}
