const cds = require('../../_runtime/cds')

const getTemplate = require('../../_runtime/common/utils/template')
const templateProcessor = require('../../_runtime/common/utils/templateProcessor')

const _getParent = (model, name) => {
  const target = model.definitions[name]

  if (target && target.elements) {
    for (const elementName in target.elements) {
      const element = target.elements[elementName]
      if (element._anchor && element._anchor._isContained) return element._anchor
    }
  }

  return null
}

const _addEtags = (row, key) => {
  if (!row[key]) return
  row.$etag = row[key].startsWith('W/') ? row[key] : `W/"${row[key]}"`
}

const _processorFn = () => elementInfo => {
  const { row, plain } = elementInfo
  if (typeof row !== 'object') return
  for (const category of plain.categories) {
    const { row, key } = elementInfo
    switch (category) {
      case '@odata.etag':
        _addEtags(row, key)
        break
      case '@cds.api.ignore':
        delete row[key]
        break
      case 'binary':
        if (Buffer.isBuffer(row[key])) {
          // if the result object gets serialize to json, the buffer shall become a base64 string
          row[key].toJSON = function () {
            return this.toString('base64')
          }
        }
        break
      case 'array':
        row[key] ??= []
        break
      // no default
    }
  }
}

const _pick = element => {
  const categories = []
  if (element['@odata.etag']) categories.push('@odata.etag')
  if (element['@cds.api.ignore']) categories.push('@cds.api.ignore')
  if (element._type === 'cds.Binary') categories.push('binary')
  if (element.items) categories.push('array')
  if (categories.length) return { categories }
}

module.exports = function postProcess(target, service, result, isMinimal) {
  if (!result) return

  let { model } = service
  if (service.isExtensible) model = cds.context?.model || model

  if (!model.definitions[target.name]) {
    if (model.definitions[target.items?.type]) target = target.items
    else return
  }

  const cacheKey = isMinimal ? 'postProcessMinimal' : 'postProcess'
  const parent = _getParent(model, target.name)
  const options = { pick: _pick, ignore: isMinimal ? el => el.isAssociation : undefined }
  const template = getTemplate(cacheKey, service, target, options, parent)

  if (template.elements.size === 0) return

  // normalize result to rows
  result = result.value != null && Object.keys(result).filter(k => !k.match(/^\W/)).length === 1 ? result.value : result

  if (typeof result === 'object' && result != null) {
    const rows = Array.isArray(result) ? result : [result]

    // process each row
    const processFn = _processorFn()
    for (const row of rows) templateProcessor({ processFn, row, template })
  }
}
